"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromURLToServer = fromURLToServer;
exports.fromURLToHorizonServer = fromURLToHorizonServer;
exports.SorobanReactProvider = SorobanReactProvider;
const react_1 = __importStar(require("react"));
const StellarSdk = __importStar(require("@stellar/stellar-sdk"));
const _1 = require(".");
/**
 * Converts network details to an active chain object.
 * @param {any} networkDetails - Details of the network.
 * @param {any[]} chains - Array of supported chains.
 * @returns {WalletChain | undefined} - Active chain object or undefined if not found.
 */
function networkToActiveChain(networkDetails, chains) {
    var _a, _b;
    const supported = networkDetails &&
        chains.find((c) => c.networkPassphrase === (networkDetails === null || networkDetails === void 0 ? void 0 : networkDetails.networkPassphrase));
    const activeChain = networkDetails && {
        id: (_a = supported === null || supported === void 0 ? void 0 : supported.id) !== null && _a !== void 0 ? _a : networkDetails.networkPassphrase,
        name: (_b = supported === null || supported === void 0 ? void 0 : supported.name) !== null && _b !== void 0 ? _b : networkDetails.network,
        networkPassphrase: networkDetails.networkPassphrase,
        iconBackground: supported === null || supported === void 0 ? void 0 : supported.iconBackground,
        iconUrl: supported === null || supported === void 0 ? void 0 : supported.iconUrl,
        unsupported: !supported,
        networkUrl: networkDetails.networkUrl,
        sorobanRpcUrl: networkDetails.sorobanRpcUrl,
    };
    return activeChain;
}
/**
 * Converts a Soroban RPC URL to a Soroban RPC server object.
 * @param {string} sorobanRpcUrl - Soroban RPC URL.
 * @returns {StellarSdk.SorobanRpc.Server} - Soroban RPC server object.
 */
function fromURLToServer(sorobanRpcUrl) {
    return new StellarSdk.SorobanRpc.Server(sorobanRpcUrl, {
        allowHttp: sorobanRpcUrl.startsWith('http://'),
    });
}
/**
 * Converts a horizon network URL to a Horizon server object.
 * @param {string} networkUrl - Network URL.
 * @returns {StellarSdk.Horizon.Server} - Horizon server object.
 */
function fromURLToHorizonServer(networkUrl) {
    return new StellarSdk.Horizon.Server(networkUrl, {
        allowHttp: networkUrl.startsWith('http://'),
    });
}
/**
 * SorobanReactProvider component.
 * Provides context for Soroban React application.
 * @param {SorobanReactProviderProps} props - Props for the component.
 */
function SorobanReactProvider({ appName, autoconnect = false, chains, activeChain = _1.defaultSorobanContext.activeChain, // Non mandatory fields default to default Context fields value
children, connectors, deployments = [], server = _1.defaultSorobanContext.server, serverHorizon = _1.defaultSorobanContext.serverHorizon, }) {
    var _a;
    const activeConnector = connectors.length && connectors.length > 1 ? connectors[1] : connectors[0];
    // const activeConnector = undefined
    const isConnectedRef = (0, react_1.useRef)(false);
    console.log('SorobanReactProvider is RELOADED');
    if (activeChain === null || activeChain === void 0 ? void 0 : activeChain.sorobanRpcUrl) {
        server = fromURLToServer(activeChain.sorobanRpcUrl);
    }
    if (activeChain === null || activeChain === void 0 ? void 0 : activeChain.networkUrl) {
        serverHorizon = fromURLToHorizonServer(activeChain.networkUrl);
    }
    const [mySorobanContext, setSorobanContext] = react_1.default.useState(Object.assign(Object.assign({}, _1.defaultSorobanContext), { deployments,
        appName,
        autoconnect,
        chains,
        connectors,
        activeConnector,
        activeChain,
        server,
        serverHorizon, connect: () => __awaiter(this, void 0, void 0, function* () {
            console.log('ENTERING CONNECT with context: ', mySorobanContext);
            if (mySorobanContext.activeConnector) {
                // Now we will check if the wallet is freighter so that we keep the old way of choosing the network from the wallet for backward compatibility
                if (mySorobanContext.activeConnector.id === 'freighter') {
                    let networkDetails = yield mySorobanContext.activeConnector.getNetworkDetails();
                    //TODO: TEMP FIX while waiting for freighter to fix soroban public rpc https://github.com/stellar/freighter/issues/1335
                    if (networkDetails.sorobanRpcUrl === "http://soroban-rpc-pubnet-prd.soroban-rpc-pubnet-prd.svc.cluster.local:8000") {
                        networkDetails.sorobanRpcUrl = "https://mainnet.stellar.validationcloud.io/v1/XFb5Lma6smizBnnRPEgYMbuNm0K3FWzJ7854GNSQ2EY";
                    }
                    let activeChain = networkToActiveChain(networkDetails, chains);
                    if (!chains.find((c) => c.networkPassphrase === (networkDetails === null || networkDetails === void 0 ? void 0 : networkDetails.networkPassphrase))) {
                        const error = new Error('Your Wallet network is not supported in this app');
                        throw error;
                    }
                    if (!(networkDetails === null || networkDetails === void 0 ? void 0 : networkDetails.sorobanRpcUrl)) {
                        const error = new Error('Soroban RPC URL is not set, please check your freighter wallet network configuration');
                        throw error;
                    }
                    server =
                        networkDetails &&
                            new StellarSdk.SorobanRpc.Server(networkDetails.sorobanRpcUrl, {
                                allowHttp: networkDetails.sorobanRpcUrl.startsWith('http://'),
                            });
                    serverHorizon =
                        networkDetails &&
                            new StellarSdk.Horizon.Server(networkDetails.networkUrl, {
                                allowHttp: networkDetails.networkUrl.startsWith('http://'),
                            });
                    console.log('SorobanReactProvider: Connecting with FREIGHTER : ', mySorobanContext.activeConnector.name);
                    let address = yield mySorobanContext.activeConnector.getPublicKey();
                    // Now we can track that the wallet is finally connected
                    isConnectedRef.current = true;
                    setSorobanContext((c) => (Object.assign(Object.assign({}, c), { activeChain,
                        address,
                        server,
                        serverHorizon })));
                }
                // If connector is any other wallet that does not have getNetworkDetails we will need to set the active chain and server from somewehere else in the front end
                else {
                    console.log('SorobanReactProvider: Connecting with ', mySorobanContext.activeConnector.name);
                    let address = yield mySorobanContext.activeConnector.getPublicKey();
                    // Now we can track that the wallet is finally connected
                    isConnectedRef.current = true;
                    setSorobanContext((c) => (Object.assign(Object.assign({}, c), { address })));
                }
            }
            else {
                console.log('SorobanReactProvider: No active Connector');
            }
        }), disconnect: () => __awaiter(this, void 0, void 0, function* () {
            isConnectedRef.current = false;
            // TODO: Maybe reset address to undefined
            // TODO: Handle other things here, such as perhaps resetting address to undefined.
            let address = undefined;
            setSorobanContext((c) => (Object.assign(Object.assign({}, c), { address })));
        }), setActiveChain: (chain) => {
            console.log('Chainging activeChain to : ', chain);
            // When the user in frontend changes the activeChain to read the blockchain without wallet
            let server = undefined, serverHorizon = undefined;
            activeChain = chain;
            if (activeChain.sorobanRpcUrl) {
                server = fromURLToServer(activeChain.sorobanRpcUrl);
            }
            if (activeChain.networkUrl) {
                serverHorizon = fromURLToHorizonServer(activeChain.networkUrl);
            }
            setSorobanContext((c) => (Object.assign(Object.assign({}, c), { server,
                serverHorizon,
                activeChain })));
        }, setActiveConnectorAndConnect: (connector) => __awaiter(this, void 0, void 0, function* () {
            console.log('Changing connector to ', connector.name);
            let activeConnector = connector;
            console.log('SorobanReactProvider: Changing connector');
            // We better connect here otherwise in the frontend the context is not updated fast enough, and the user connects to the old connector first.
            let address = yield activeConnector.getPublicKey();
            isConnectedRef.current = true;
            setSorobanContext((c) => (Object.assign(Object.assign({}, c), { activeConnector,
                address })));
        }) }));
    console.log('SorobanReactProvider: Active connector is ', (_a = mySorobanContext.activeConnector) === null || _a === void 0 ? void 0 : _a.name);
    // Handle changes of address in "realtime"
    react_1.default.useEffect(() => {
        let timeoutId = null;
        // If it turns out that requesting an update from Freighter is too taxing,
        // then this could be increased. Humans perceive 100ms response times as instantaneous
        // (source: https://www.pubnub.com/blog/how-fast-is-realtime-human-perception-and-technology/)
        // but you also have to consider the re-render time of components.
        const freighterCheckIntervalMs = 200;
        function checkForAddressChanges() {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                // Returns if not installed / not active / not connected (TODO: currently always isConnected=true)
                if (!mySorobanContext.activeConnector ||
                    !mySorobanContext.activeConnector.isConnected() ||
                    !isConnectedRef.current ||
                    !mySorobanContext.activeChain)
                    return;
                // For now we can only do this with freighter. xBull doesn't handle the repeated call well.
                else if (mySorobanContext.activeConnector.id !== 'freighter') {
                    return;
                }
                else {
                    let hasNoticedWalletUpdate = false;
                    try {
                        // NOTICE: If the user logs out from or uninstalls the Freighter extension while they are connected
                        // on this site, then a dialog will appear asking them to sign in again. We need a way to ask Freighter
                        // if there is _any_ connected user, without actually asking them to sign in. Unfortunately, that is not
                        // supported at this time; but it would be easy to submit a PR to the extension to add support for it.
                        let address = yield ((_a = mySorobanContext.activeConnector) === null || _a === void 0 ? void 0 : _a.getPublicKey());
                        // TODO: If you want to know when the user has disconnected, then you can set a timeout for getPublicKey.
                        // If it doesn't return in X milliseconds, you can be pretty confident that they aren't connected anymore.
                        if (mySorobanContext.address !== address) {
                            console.log('SorobanReactProvider: address changed from:', mySorobanContext.address, ' to: ', address);
                            hasNoticedWalletUpdate = true;
                            console.log('SorobanReactProvider: reconnecting');
                            setSorobanContext((c) => (Object.assign(Object.assign({}, c), { address })));
                        }
                    }
                    catch (error) {
                        // I would recommend keeping the try/catch so that any exceptions in this async function
                        // will get handled. Otherwise React could complain. I believe that eventually it may cause huge
                        // problems, but that might be a NodeJS specific approach to exceptions not handled in promises.
                        console.error('SorobanReactProvider: error: ', error);
                    }
                    finally {
                        if (!hasNoticedWalletUpdate)
                            timeoutId = setTimeout(checkForAddressChanges, freighterCheckIntervalMs);
                    }
                }
            });
        }
        checkForAddressChanges();
        return () => {
            if (timeoutId != null)
                clearTimeout(timeoutId);
        };
    }, [mySorobanContext]);
    // Handle changes of network in "realtime" if getNetworkDetails exists
    react_1.default.useEffect(() => {
        let timeoutId = null;
        const freighterCheckIntervalMs = 200;
        function checkForNetworkChanges() {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                // Returns if not installed / not active / not connected (TODO: currently always isConnected=true)
                if (!mySorobanContext.activeConnector ||
                    !mySorobanContext.activeConnector.isConnected() ||
                    !isConnectedRef.current ||
                    !mySorobanContext.activeChain)
                    return;
                // For now we can only do this with freighter. xBull doesn't have the getNetworkDetails method exposed.
                else if (mySorobanContext.activeConnector.id !== 'freighter') {
                    return;
                }
                else {
                    let hasNoticedWalletUpdate = false;
                    try {
                        let networkDetails = yield mySorobanContext.activeConnector.getNetworkDetails();
                        //TODO: TEMP FIX while waiting for freighter to fix soroban public rpc https://github.com/stellar/freighter/issues/1335
                        if (networkDetails.sorobanRpcUrl === "http://soroban-rpc-pubnet-prd.soroban-rpc-pubnet-prd.svc.cluster.local:8000") {
                            networkDetails.sorobanRpcUrl = "https://mainnet.stellar.validationcloud.io/v1/XFb5Lma6smizBnnRPEgYMbuNm0K3FWzJ7854GNSQ2EY";
                        }
                        let newActiveChain = networkToActiveChain(networkDetails, chains);
                        // We check that we have a valid network details and not a blank one like the one xbull connector would return
                        if (networkDetails.network &&
                            (newActiveChain.networkPassphrase !==
                                mySorobanContext.activeChain.networkPassphrase ||
                                (newActiveChain === null || newActiveChain === void 0 ? void 0 : newActiveChain.sorobanRpcUrl) !==
                                    ((_a = mySorobanContext === null || mySorobanContext === void 0 ? void 0 : mySorobanContext.activeChain) === null || _a === void 0 ? void 0 : _a.sorobanRpcUrl))) {
                            console.log('SorobanReactProvider: network changed from:', mySorobanContext.activeChain.networkPassphrase, ' to: ', newActiveChain.networkPassphrase);
                            hasNoticedWalletUpdate = true;
                            mySorobanContext.setActiveChain &&
                                mySorobanContext.setActiveChain(newActiveChain);
                        }
                    }
                    catch (error) {
                        console.error('SorobanReactProvider: error: ', error);
                    }
                    finally {
                        if (!hasNoticedWalletUpdate)
                            timeoutId = setTimeout(checkForNetworkChanges, freighterCheckIntervalMs);
                    }
                }
            });
        }
        checkForNetworkChanges();
        return () => {
            if (timeoutId != null)
                clearTimeout(timeoutId);
        };
    }, [mySorobanContext]);
    // TODO: ASSESS THE USE OF THIS
    // React.useEffect(() => {
    //   if (mySorobanContext.address) return // If we already have access to the connector's address, we are OK
    //   if (!mySorobanContext.activeConnector) return // If there is not even an activeConnector, we don't need to continue
    //   // activeConnector.isConnected() means that the connector is installed (even if not allowed, even if locked)
    //   // Hence, here we want to connect automatically if autoconnect is true && if activeConnector is installed
    //   if (
    //     mySorobanContext.autoconnect &&
    //     mySorobanContext.activeConnector.isConnected()
    //   ) {
    //     // TODO: When the page loads, autoconnect==true and the user is not signed in, this gets called twice
    //     // (due to the sorobanContext.activeConnector being seen as different by React), which causes
    //     // the Wallet window to appear twice.
    //     // An easy approach will be to use a ref in the connect function so that if it's already
    //     // trying to connect from somewhere else, then it doesn't try again
    //     // (since getPublicKey is what is causing the popup to appear)
    //     // This should be programmed in every connector for every get function
    //     mySorobanContext.connect()
    //   }
    // }, [mySorobanContext.activeConnector, mySorobanContext.autoconnect])
    return (react_1.default.createElement(_1.SorobanContext.Provider, { value: mySorobanContext }, children));
}
